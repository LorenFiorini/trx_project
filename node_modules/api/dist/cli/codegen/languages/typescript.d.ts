import type Oas from 'oas';
import type { Operation } from 'oas';
import type { JSONSchema, SchemaObject } from 'oas/@types/rmoas.types';
import type { ClassDeclaration, MethodDeclaration } from 'ts-morph';
import type Storage from '../../storage';
import type { InstallerOptions } from '../language';
import CodeGeneratorLanguage from '../language';
import { Project } from 'ts-morph';
declare type OperationTypeHousing = {
    types: {
        params?: false | Record<'body' | 'formData' | 'metadata', string>;
        responses?: Record<string, string>;
    };
    operation: Operation;
};
export default class TSGenerator extends CodeGeneratorLanguage {
    project: Project;
    outputJS: boolean;
    compilerTarget: 'cjs' | 'esm';
    types: Map<string, string>;
    files: Record<string, string>;
    methodGenerics: Map<string, MethodDeclaration>;
    sdk: ClassDeclaration;
    schemas: Map<string, {
        schema: SchemaObject;
        name: string;
        tsType?: string;
    }>;
    constructor(spec: Oas, specPath: string, identifier: string, opts?: {
        outputJS?: boolean;
        compilerTarget?: 'cjs' | 'esm';
    });
    static formatter(content: string): string;
    installer(storage: Storage, opts?: InstallerOptions): Promise<void>;
    /**
     * Compile the current OpenAPI definition into a TypeScript library.
     *
     */
    generator(): Promise<{
        [x: string]: string;
    }>;
    /**
     * Create a generic HTTP method accessor on the SDK.
     *
     * @param method
     */
    createGenericMethodAccessor(method: string): void;
    /**
     * Create operation accessors on the SDK.
     *
     * @param operation
     * @param operationId
     * @param paramTypes
     * @param responseTypes
     */
    createOperationAccessor(operation: Operation, operationId: string, paramTypes?: OperationTypeHousing['types']['params'], responseTypes?: OperationTypeHousing['types']['responses']): void;
    /**
     * Convert a JSON Schema object into a readily available TypeScript type or interface along with
     * any `$ref` pointers that are in use and turn those into TS types too.
     *
     * Under the hood this uses https://npm.im/json-schema-to-typescript for all composition and
     * conversion.
     *
     * @param schema
     * @param name
     */
    convertJSONSchemaToTypescript(schema: JSONSchema, name: string): Promise<{
        primaryType: string;
    }>;
    /**
     * Scour through the current OpenAPI definition and compile a store of every operation, along
     * with every HTTP method that's in use, and their available TypeScript types that we can use,
     * along with every HTTP method that's in use.
     *
     */
    loadOperationsAndMethods(): Promise<{
        operations: Record<string, OperationTypeHousing>;
        methods: Set<unknown>;
    }>;
    /**
     * Compile the parameter (path, query, cookie, and header) schemas for an API operation into
     * usable TypeScript types.
     *
     * @param operation
     * @param operationId
     */
    prepareParameterTypesForOperation(operation: Operation, operationId: string): false | Record<"formData" | "body" | "metadata", string>;
    /**
     * Compile the response schemas for an API operation into usable TypeScript types.
     *
     * @todo what does this do for a spec that has no responses?
     * @param operation
     * @param operationId
     */
    prepareResponseTypesForOperation(operation: Operation, operationId: string): {
        [x: string]: string;
    };
}
export {};
