"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var language_1 = __importDefault(require("../language"));
var logger_1 = __importDefault(require("../../logger"));
var object_hash_1 = __importDefault(require("object-hash"));
var ts_morph_1 = require("ts-morph");
var json_schema_to_typescript_1 = require("json-schema-to-typescript");
var formatter_1 = require("json-schema-to-typescript/dist/src/formatter");
var execa_1 = __importDefault(require("execa"));
// https://www.30secondsofcode.org/js/s/word-wrap
function wordWrap(str, max) {
    if (max === void 0) { max = 88; }
    return str.replace(new RegExp("(?![^\\n]{1,".concat(max, "}$)([^\\n]{1,").concat(max, "})\\s"), 'g'), '$1\n');
}
var TSGenerator = /** @class */ (function (_super) {
    __extends(TSGenerator, _super);
    function TSGenerator(spec, specPath, identifier, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = this;
        var options = __assign({ outputJS: false, compilerTarget: 'cjs' }, opts);
        if (!options.outputJS) {
            // TypeScript compilation will always target towards ESM-like imports and exports.
            options.compilerTarget = 'esm';
        }
        _this = _super.call(this, spec, specPath, identifier) || this;
        _this.requiredPackages = {
            'api@beta': {
                reason: "Required for the `api/dist/core` library that the codegen'd SDK uses for making requests.",
                url: 'https://npm.im/api'
            },
            oas: {
                reason: 'Used within `api/dist/core` and is also loaded for TypeScript types.',
                url: 'https://npm.im/oas'
            }
        };
        _this.project = new ts_morph_1.Project({
            manipulationSettings: {
                indentationText: ts_morph_1.IndentationText.TwoSpaces,
                quoteKind: ts_morph_1.QuoteKind.Single
            },
            compilerOptions: __assign({ declaration: true, resolveJsonModule: true, target: options.compilerTarget === 'cjs' ? ts_morph_1.ScriptTarget.ES5 : ts_morph_1.ScriptTarget.ES2020, outDir: 'dist' }, (options.compilerTarget === 'cjs' ? { esModuleInterop: true } : {}))
        });
        _this.compilerTarget = options.compilerTarget;
        _this.outputJS = options.outputJS;
        _this.types = new Map();
        _this.methodGenerics = new Map();
        _this.schemas = new Map();
        return _this;
    }
    TSGenerator.formatter = function (content) {
        return (0, formatter_1.format)(content, {
            format: true,
            style: {
                printWidth: 120,
                singleQuote: true
            }
        });
    };
    TSGenerator.prototype.installer = function (storage, opts) {
        if (opts === void 0) { opts = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var installDir, pkg, npmInstall;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        installDir = storage.getIdentifierStorageDir();
                        pkg = {
                            name: "@api/".concat(storage.identifier),
                            main: "./index.".concat(this.outputJS ? 'js' : 'ts'),
                            types: './index.d.ts'
                        };
                        fs_1["default"].writeFileSync(path_1["default"].join(installDir, 'package.json'), JSON.stringify(pkg, null, 2));
                        npmInstall = ['install', '--save', opts.dryRun ? '--dry-run' : ''].filter(Boolean);
                        // This will install packages required for the SDK within its installed directory in `.apis/`.
                        return [4 /*yield*/, (0, execa_1["default"])('npm', __spreadArray(__spreadArray([], npmInstall, true), Object.keys(this.requiredPackages), true).filter(Boolean), {
                                cwd: installDir
                            }).then(function (res) {
                                if (opts.dryRun) {
                                    (opts.logger ? opts.logger : logger_1["default"])(res.command);
                                    (opts.logger ? opts.logger : logger_1["default"])(res.stdout);
                                }
                            })];
                    case 1:
                        // This will install packages required for the SDK within its installed directory in `.apis/`.
                        _a.sent();
                        // This will install the installed SDK as a dependency within the current working directory,
                        // adding `@api/<sdk identifier>` as a dependency there so you can load it with
                        // `require('@api/<sdk identifier>)`.
                        return [2 /*return*/, (0, execa_1["default"])('npm', __spreadArray(__spreadArray([], npmInstall, true), [storage.getIdentifierStorageDir()], false).filter(Boolean)).then(function (res) {
                                if (opts.dryRun) {
                                    (opts.logger ? opts.logger : logger_1["default"])(res.command);
                                    (opts.logger ? opts.logger : logger_1["default"])(res.stdout);
                                }
                            })];
                }
            });
        });
    };
    /**
     * Compile the current OpenAPI definition into a TypeScript library.
     *
     */
    TSGenerator.prototype.generator = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, operations, methods, sdkSource;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.loadOperationsAndMethods()];
                    case 1:
                        _a = _b.sent(), operations = _a.operations, methods = _a.methods;
                        sdkSource = this.project.createSourceFile('index.ts', '');
                        sdkSource.addImportDeclarations([
                            { defaultImport: 'Oas', moduleSpecifier: 'oas' },
                            { defaultImport: 'APICore', moduleSpecifier: 'api/dist/core' },
                            { defaultImport: 'definition', moduleSpecifier: this.specPath },
                        ]);
                        // @todo add TOS, License, info.* to a docblock at the top of the SDK.
                        this.sdk = sdkSource.addClass({
                            name: 'SDK'
                        });
                        // There's an annoying quirk with `ts-morph` where if we set the SDK class to be the default
                        // export with `isDefaultExport` then when we compile it to an ES5 target for CJS environments
                        // it'll be exported as `export.default = SDK`, which when you try to load it you'll need to
                        // run `require('@api/sdk').default`.
                        //
                        // Instead here by plainly creating the SDK class in the source file and then setting this
                        // export assignment it'll export the SDK class as `module.exports = SDK` so people can cleanly
                        // load the SDK with `require('@api/sdk)`.
                        //
                        // A whole lot of debugging went into here to let people not have to worry about `.default`
                        // messes. I hope it's worth it!
                        if (this.compilerTarget === 'cjs') {
                            sdkSource.addExportAssignment({
                                expression: 'SDK'
                            });
                        }
                        else {
                            this.sdk.setIsDefaultExport(true);
                        }
                        this.sdk.addProperties([
                            { name: 'spec', type: 'Oas' },
                            { name: 'core', type: 'APICore' },
                            { name: 'authKeys', type: '(number | string)[][]', initializer: '[]' },
                        ]);
                        this.sdk.addConstructor({
                            statements: function (writer) {
                                writer.writeLine('this.spec = Oas.init(definition);');
                                writer.write('this.core = new APICore(this.spec, ').quote(_this.userAgent).write(');');
                                return writer;
                            }
                        });
                        // Add our core API methods for controlling auth, servers, and various configurable abilities.
                        sdkSource.addInterface({
                            name: 'ConfigOptions',
                            properties: [
                                {
                                    name: 'parseResponse',
                                    type: 'boolean',
                                    docs: [
                                        wordWrap('By default we parse the response based on the `Content-Type` header of the request. You can disable this functionality by negating this option.'),
                                    ]
                                },
                            ]
                        });
                        this.sdk.addMethods([
                            {
                                name: 'config',
                                parameters: [{ name: 'config', type: 'ConfigOptions' }],
                                statements: function (writer) { return writer.writeLine('this.core.setConfig(config);'); },
                                docs: [
                                    {
                                        description: function (writer) {
                                            return writer.writeLine(wordWrap('Optionally configure various options, such as response parsing, that the SDK allows.'));
                                        },
                                        tags: [
                                            { tagName: 'param', text: 'config Object of supported SDK options and toggles.' },
                                            {
                                                tagName: 'param',
                                                text: 'config.parseResponse If responses are parsed according to its `Content-Type` header.'
                                            },
                                        ]
                                    },
                                ]
                            },
                            {
                                name: 'auth',
                                parameters: [{ name: '...values', type: 'string[] | number[]' }],
                                statements: function (writer) {
                                    writer.writeLine('this.core.setAuth(...values);');
                                    writer.writeLine('return this;');
                                    return writer;
                                },
                                docs: [
                                    {
                                        description: function (writer) {
                                            return writer.writeLine(wordWrap("If the API you're using requires authentication you can supply the required credentials through this method and the library will magically determine how they should be used within your API request.\n\nWith the exception of OpenID and MutualTLS, it supports all forms of authentication supported by the OpenAPI specification.\n\n@example <caption>HTTP Basic auth</caption>\nsdk.auth('username', 'password');\n\n@example <caption>Bearer tokens (HTTP or OAuth 2)</caption>\nsdk.auth('myBearerToken');\n\n@example <caption>API Keys</caption>\nsdk.auth('myApiKey');"));
                                        },
                                        tags: [
                                            { tagName: 'see', text: '{@link https://spec.openapis.org/oas/v3.0.3#fixed-fields-22}' },
                                            { tagName: 'see', text: '{@link https://spec.openapis.org/oas/v3.1.0#fixed-fields-22}' },
                                            {
                                                tagName: 'param',
                                                text: 'values Your auth credentials for the API; can specify up to two strings or numbers.'
                                            },
                                        ]
                                    },
                                ]
                            },
                            {
                                name: 'server',
                                parameters: [
                                    { name: 'url', type: 'string' },
                                    { name: 'variables', initializer: '{}' },
                                ],
                                statements: function (writer) { return writer.writeLine('this.core.setServer(url, variables);'); },
                                docs: [
                                    {
                                        description: function (writer) {
                                            return writer.writeLine(wordWrap("If the API you're using offers alternate server URLs, and server variables, you can tell the SDK which one to use with this method. To use it you can supply either one of the server URLs that are contained within the OpenAPI definition (along with any server variables), or you can pass it a fully qualified URL to use (that may or may not exist within the OpenAPI definition).\n\n@example <caption>Server URL with server variables</caption>\nsdk.server('https://{region}.api.example.com/{basePath}', {\n  name: 'eu',\n  basePath: 'v14',\n});\n\n@example <caption>Fully qualified server URL</caption>\nsdk.server('https://eu.api.example.com/v14');"));
                                        },
                                        tags: [
                                            { tagName: 'param', text: 'url Server URL' },
                                            { tagName: 'param', text: 'variables An object of variables to replace into the server URL.' },
                                        ]
                                    },
                                ]
                            },
                        ]);
                        // Add all common method accessors into the SDK.
                        Array.from(methods).forEach(function (method) { return _this.createGenericMethodAccessor(method); });
                        // Add all available operation ID accessors into the SDK.
                        Object.entries(operations).forEach(function (_a) {
                            var operationId = _a[0], data = _a[1];
                            _this.createOperationAccessor(data.operation, operationId, data.types.params, data.types.responses);
                        });
                        // @todo should all of these isolated into their own file outside of the main sdk class file?
                        // Add all known types that we're using into the SDK.
                        Array.from(this.types.values()).forEach(function (exp) {
                            sdkSource.addStatements(exp);
                        });
                        if (this.outputJS) {
                            return [2 /*return*/, this.project
                                    .emitToMemory()
                                    .getFiles()
                                    .map(function (sourceFile) {
                                    var _a;
                                    return (_a = {},
                                        _a[path_1["default"].basename(sourceFile.filePath)] = TSGenerator.formatter(sourceFile.text),
                                        _a);
                                })
                                    .reduce(function (prev, next) { return Object.assign(prev, next); })];
                        }
                        return [2 /*return*/, __spreadArray(__spreadArray([], this.project.getSourceFiles().map(function (sourceFile) {
                                var _a;
                                return (_a = {},
                                    _a[sourceFile.getBaseName()] = TSGenerator.formatter(sourceFile.getFullText()),
                                    _a);
                            }), true), this.project
                                .emitToMemory({ emitOnlyDtsFiles: true })
                                .getFiles()
                                .map(function (sourceFile) {
                                var _a;
                                return (_a = {},
                                    _a[path_1["default"].basename(sourceFile.filePath)] = TSGenerator.formatter(sourceFile.text),
                                    _a);
                            }), true).reduce(function (prev, next) { return Object.assign(prev, next); })];
                }
            });
        });
    };
    /**
     * Create a generic HTTP method accessor on the SDK.
     *
     * @param method
     */
    TSGenerator.prototype.createGenericMethodAccessor = function (method) {
        var parameters = [{ name: 'path', type: 'string' }];
        var docblock = {
            description: function (writer) {
                writer.writeLine("Access any ".concat(method, " endpoint on your API."));
                return writer;
            },
            tags: [{ tagName: 'param', text: 'path API path to make a request against.' }]
        };
        // Method generic body + metadata parameters are always optional.
        if (method !== 'get') {
            parameters.push({ name: 'body', type: 'unknown', hasQuestionToken: true });
            docblock.tags.push({ tagName: 'param', text: 'body Request body payload data.' });
        }
        parameters.push({ name: 'metadata', type: 'Record<string, unknown>', hasQuestionToken: true });
        docblock.tags.push({
            tagName: 'param',
            text: 'metadata Object containing all path, query, header, and cookie parameters to supply.'
        });
        this.methodGenerics.set(method, this.sdk.addMethod({
            name: method,
            returnType: 'Promise<T>',
            parameters: parameters,
            typeParameters: ['T = unknown'],
            docs: [docblock],
            statements: function (writer) {
                /**
                 * @example return this.core.fetch(path, 'get', body, metadata);
                 * @example return this.core.fetch(path, 'get', metadata);
                 */
                var fetchStmt = writer.write('return this.core.fetch(path, ').quote(method).write(', ');
                var fetchArgs = parameters.slice(1).map(function (p) { return p.name; });
                fetchArgs.forEach(function (arg, i) {
                    fetchStmt.write(arg);
                    if (fetchArgs.length > 1 && i !== fetchArgs.length) {
                        fetchStmt.write(', ');
                    }
                });
                fetchStmt.write(');');
                return fetchStmt;
            }
        }));
    };
    /**
     * Create operation accessors on the SDK.
     *
     * @param operation
     * @param operationId
     * @param paramTypes
     * @param responseTypes
     */
    TSGenerator.prototype.createOperationAccessor = function (operation, operationId, paramTypes, responseTypes) {
        var _this = this;
        var docblock = { tags: [] };
        var summary = operation.getSummary();
        var description = operation.getDescription();
        if (summary || description) {
            // To keep our generated docblocks clean we should only add the `@summary` tag if we've
            // got both a summary and a description present on the operation, otherwise we can alternate
            // what we surface the main docblock description.
            docblock.description = function (writer) {
                if (description) {
                    writer.writeLine(description);
                }
                else if (summary) {
                    writer.writeLine(summary);
                }
                writer.newLineIfLastNot();
                return writer;
            };
            if (summary && description) {
                docblock.tags.push({ tagName: 'summary', text: summary });
            }
        }
        var hasOptionalBody = false;
        var hasOptionalMetadata = false;
        var parameters = {};
        if (paramTypes) {
            // If an operation has a request body payload it will only ever have `body` or `formData`,
            // never both, as these are determined upon the media type that's in use.
            if (paramTypes.body || paramTypes.formData) {
                hasOptionalBody = !operation.hasRequiredRequestBody();
                parameters.body = {
                    name: 'body',
                    type: paramTypes.body
                        ? this.schemas.get(paramTypes.body).tsType
                        : this.schemas.get(paramTypes.formData).tsType,
                    hasQuestionToken: hasOptionalBody
                };
            }
            if (paramTypes.metadata) {
                hasOptionalMetadata = !operation.hasRequiredParameters();
                parameters.metadata = {
                    name: 'metadata',
                    type: this.schemas.get(paramTypes.metadata).tsType,
                    hasQuestionToken: hasOptionalMetadata
                };
            }
        }
        var returnType = 'Promise<T>';
        var typeParameters = null;
        if (responseTypes) {
            returnType = "Promise<".concat(Object.values(responseTypes)
                .map(function (hash) { return _this.schemas.get(hash).tsType; })
                .join(' | '), ">");
        }
        else {
            // We should only add the `<T>` method typing if we don't have any response types present.
            typeParameters = ['T = unknown'];
        }
        var operationIdAccessor = this.sdk.addMethod({
            name: operationId,
            typeParameters: typeParameters,
            returnType: returnType,
            docs: docblock ? [docblock] : null,
            statements: function (writer) {
                /**
                 * @example return this.core.fetch('/pet/findByStatus', 'get', body, metadata);
                 * @example return this.core.fetch('/pet/findByStatus', 'get', metadata);
                 */
                var fetchStmt = writer
                    .write('return this.core.fetch(')
                    .quote(operation.path)
                    .write(', ')
                    .quote(operation.method);
                var totalParams = Object.keys(parameters).length;
                if (totalParams) {
                    Object.values(parameters).forEach(function (arg, i) {
                        if (i === 0) {
                            fetchStmt.write(', ');
                        }
                        fetchStmt.write(arg.name);
                        if (totalParams > 1 && i !== totalParams) {
                            fetchStmt.write(', ');
                        }
                    });
                }
                fetchStmt.write(');');
                return fetchStmt;
            }
        });
        // If we have both body and metadata parameters but only body is optional we need to create
        // a couple function overloads as Typescript doesn't let us have an optional method parameter
        // come before one that's required.
        //
        // None of these accessor overloads will receive a docblock because the original will have
        // that covered.
        var shouldAddAltTypedOverloads = Object.keys(parameters).length === 2 && hasOptionalBody && !hasOptionalMetadata;
        if (shouldAddAltTypedOverloads) {
            // Create an overload that has both `body` and `metadata` parameters as required.
            operationIdAccessor.addOverload({
                typeParameters: typeParameters,
                parameters: [
                    __assign(__assign({}, parameters.body), { hasQuestionToken: false }),
                    __assign(__assign({}, parameters.metadata), { hasQuestionToken: false }),
                ],
                returnType: returnType,
                docs: docblock ? [docblock] : null
            });
            // Create an overload that just has a single `metadata` parameter.
            operationIdAccessor.addOverload({
                typeParameters: typeParameters,
                parameters: [__assign({}, parameters.metadata)],
                returnType: returnType,
                docs: docblock ? [docblock] : null
            });
            // Create an overload that has both `body` and `metadata` parameters as optional. Even though
            // our `metadata` parameter is actually required for this operation this is the only way we're
            // able to have an optional `body` parameter be present before `metadata`.
            //
            // Thankfully our core fetch work in `api/dist/core` is able to do the proper determination to
            // see if what the user is supplying is `metadata` or `body` content when they supply one or
            // both.
            operationIdAccessor.addParameters([
                __assign(__assign({}, parameters.body), { hasQuestionToken: true }),
                __assign(__assign({}, parameters.metadata), { hasQuestionToken: true }),
            ]);
        }
        else {
            operationIdAccessor.addParameters(Object.values(parameters));
        }
        // Add a typed generic HTTP method overload for this operation.
        if (this.methodGenerics.has(operation.method)) {
            // If we created alternate overloads for the operation accessor then we need to do the same
            // for its generic HTTP counterpart.
            if (shouldAddAltTypedOverloads) {
                // Create an overload that has both `body` and `metadata` parameters as required.
                this.methodGenerics.get(operation.method).addOverload({
                    typeParameters: typeParameters,
                    parameters: [
                        { name: 'path', type: 'string' },
                        __assign(__assign({}, parameters.body), { hasQuestionToken: false }),
                        __assign(__assign({}, parameters.metadata), { hasQuestionToken: false }),
                    ],
                    returnType: returnType,
                    docs: docblock ? [docblock] : null
                });
                // Create an overload that just has a single `metadata` parameter.
                this.methodGenerics.get(operation.method).addOverload({
                    typeParameters: typeParameters,
                    parameters: [{ name: 'path', type: 'string' }, parameters.metadata],
                    returnType: returnType,
                    docs: docblock ? [docblock] : null
                });
            }
            else {
                this.methodGenerics.get(operation.method).addOverload({
                    typeParameters: responseTypes ? null : ['T = unknown'],
                    parameters: __spreadArray([{ name: 'path', type: 'string' }], Object.values(parameters), true),
                    returnType: returnType,
                    docs: docblock ? [docblock] : null
                });
            }
        }
    };
    /**
     * Convert a JSON Schema object into a readily available TypeScript type or interface along with
     * any `$ref` pointers that are in use and turn those into TS types too.
     *
     * Under the hood this uses https://npm.im/json-schema-to-typescript for all composition and
     * conversion.
     *
     * @param schema
     * @param name
     */
    TSGenerator.prototype.convertJSONSchemaToTypescript = function (schema, name) {
        return __awaiter(this, void 0, void 0, function () {
            var ts, primaryType, tempProject, declarations;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, json_schema_to_typescript_1.compile)(schema, name, {
                            bannerComment: '',
                            // Running Prettier here for every JSON Schema object we're generating is way too slow so
                            // we're instead running it at the very end after we've constructed the SDK.
                            format: false
                        })];
                    case 1:
                        ts = _a.sent();
                        tempProject = this.project.createSourceFile("".concat(name, ".types.tmp.ts"), ts);
                        declarations = tempProject.getExportedDeclarations();
                        Array.from(declarations.keys()).forEach(function (declarationName) {
                            if (!primaryType) {
                                primaryType = declarationName;
                            }
                            declarations.get(declarationName).forEach(function (declaration) {
                                _this.types.set(declarationName, declaration.getText());
                            });
                        });
                        this.project.removeSourceFile(tempProject);
                        return [2 /*return*/, {
                                primaryType: primaryType
                            }];
                }
            });
        });
    };
    /**
     * Scour through the current OpenAPI definition and compile a store of every operation, along
     * with every HTTP method that's in use, and their available TypeScript types that we can use,
     * along with every HTTP method that's in use.
     *
     */
    TSGenerator.prototype.loadOperationsAndMethods = function () {
        return __awaiter(this, void 0, void 0, function () {
            var operations, methods;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        operations = {};
                        methods = new Set();
                        // Prepare all of the schemas that we need to process for every operation within this API
                        // definition.
                        Object.entries(this.spec.getPaths()).forEach(function (_a) {
                            var ops = _a[1];
                            Object.entries(ops).forEach(function (_a) {
                                var method = _a[0], operation = _a[1];
                                methods.add(method);
                                var operationId = operation.getOperationId();
                                var params = _this.prepareParameterTypesForOperation(operation, operationId);
                                var responses = _this.prepareResponseTypesForOperation(operation, operationId);
                                if (operation.hasOperationId()) {
                                    operations[operation.getOperationId()] = {
                                        types: {
                                            params: params,
                                            responses: responses
                                        },
                                        operation: operation
                                    };
                                }
                            });
                        });
                        // Run through and convert every schema we need to use into TS types.
                        return [4 /*yield*/, Promise.all(Array.from(this.schemas.entries()).map(function (_a) {
                                var hash = _a[0], _b = _a[1], schema = _b.schema, schemaName = _b.name;
                                return __awaiter(_this, void 0, void 0, function () {
                                    var ts;
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0: return [4 /*yield*/, this.convertJSONSchemaToTypescript(schema, schemaName)];
                                            case 1:
                                                ts = _c.sent();
                                                this.schemas.set(hash, __assign(__assign({}, this.schemas.get(hash)), { tsType: ts.primaryType }));
                                                return [2 /*return*/];
                                        }
                                    });
                                });
                            }))];
                    case 1:
                        // Run through and convert every schema we need to use into TS types.
                        _a.sent();
                        return [2 /*return*/, {
                                operations: operations,
                                methods: methods
                            }];
                }
            });
        });
    };
    /**
     * Compile the parameter (path, query, cookie, and header) schemas for an API operation into
     * usable TypeScript types.
     *
     * @param operation
     * @param operationId
     */
    TSGenerator.prototype.prepareParameterTypesForOperation = function (operation, operationId) {
        var _this = this;
        var schemas = operation.getParametersAsJsonSchema({
            mergeIntoBodyAndMetadata: true,
            retainDeprecatedProperties: true
        });
        if (!schemas || !schemas.length) {
            return false;
        }
        var res = schemas
            .map(function (param) {
            var _a;
            return (_a = {}, _a[param.type] = param.schema, _a);
        })
            .reduce(function (prev, next) { return Object.assign(prev, next); });
        return Object.entries(res)
            .map(function (_a) {
            var _b;
            var paramType = _a[0], schema = _a[1];
            var schemaName = schema['x-readme-ref-name'] || "".concat(operationId, "_").concat(paramType, "_param");
            var hash = (0, object_hash_1["default"])({
                name: schemaName,
                schema: schema
            });
            if (!_this.schemas.has(hash)) {
                _this.schemas.set(hash, {
                    schema: schema,
                    name: schemaName
                });
            }
            return _b = {},
                _b[paramType] = hash,
                _b;
        })
            .reduce(function (prev, next) { return Object.assign(prev, next); }, {});
    };
    /**
     * Compile the response schemas for an API operation into usable TypeScript types.
     *
     * @todo what does this do for a spec that has no responses?
     * @param operation
     * @param operationId
     */
    TSGenerator.prototype.prepareResponseTypesForOperation = function (operation, operationId) {
        var _this = this;
        var schemas = operation
            .getResponseStatusCodes()
            .map(function (status) {
            var _a;
            var schema = operation.getResponseAsJsonSchema(status);
            if (!schema) {
                return false;
            }
            return _a = {},
                _a[status] = schema.shift(),
                _a;
        })
            .reduce(function (prev, next) { return Object.assign(prev, next); });
        var res = Object.entries(schemas)
            .map(function (_a) {
            var _b;
            var status = _a[0], schema = _a[1].schema;
            var schemaName = schema['x-readme-ref-name'] || "".concat(operationId, "_Response_").concat(status);
            var hash = (0, object_hash_1["default"])({
                name: schemaName,
                schema: schema
            });
            if (!_this.schemas.has(hash)) {
                _this.schemas.set(hash, {
                    schema: schema,
                    name: schemaName
                });
            }
            return _b = {},
                _b[status] = hash,
                _b;
        })
            .reduce(function (prev, next) { return Object.assign(prev, next); }, {});
        return Object.keys(res).length ? res : undefined;
    };
    return TSGenerator;
}(language_1["default"]));
exports["default"] = TSGenerator;
